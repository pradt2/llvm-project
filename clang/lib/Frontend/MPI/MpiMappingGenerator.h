//
// Created by p on 09/03/2022.
//

#ifndef CLANG_MPIMAPPINGGENERATOR_H
#define CLANG_MPIMAPPINGGENERATOR_H

#include "../SemaIR/SemaIR.h"

class MpiMappingGenerator {

  struct MpiElement {
    std::vector<std::string> blockLengths;
    std::vector<std::string> types;
    std::vector<std::string> offsets;
  };

  MpiElement mapMpiElement(SemaFieldDecl &decl) {
    std::string relativeElementOffset = "offsetof(" + decl.parent->fullyQualifiedName + ", " + decl.name + ")";
    return mapMpiElement(*decl.type, relativeElementOffset);
  }

  MpiElement mapMpiElement(SemaType &type, std::string relativeElementOffset) {
    MpiElement element;

    if (type.isEnumType()) {
      return mapMpiElement(((SemaEnumType&) type).integerType, relativeElementOffset);
    }

    if (type.isPrimitiveType()) {
      element.blockLengths.push_back("1");
      element.offsets.push_back(relativeElementOffset);
      BuiltinType::Kind kind = ((SemaPrimitiveType&)type).typeKind;
      switch (kind) {
      case BuiltinType::Kind::Float:
        element.types.push_back("MPI_FLOAT");
        break;
      case BuiltinType::Kind::Double:
        element.types.push_back("MPI_DOUBLE");
        break;
      case BuiltinType::Kind::LongDouble:
        element.types.push_back("MPI_LONG_DOUBLE");
        break;
      case BuiltinType::Kind::Bool:
        element.types.push_back("MPI_BYTE");
        break;
      case BuiltinType::Kind::Char_S:
      case BuiltinType::Kind::SChar:
        element.types.push_back("MPI_CHAR");
        break;
      case BuiltinType::Kind::Char_U:
      case BuiltinType::Kind::UChar:
        element.types.push_back("MPI_UNSIGNED_CHAR");
        break;
      case BuiltinType::Kind::WChar_S:
      case BuiltinType::Kind::WChar_U:
        element.types.push_back("MPI_WCHAR");
        break;
      case BuiltinType::Kind::Short:
        element.types.push_back("MPI_SHORT");
        break;
      case BuiltinType::Kind::UShort:
        element.types.push_back("MPI_UNSIGNED_SHORT");
        break;
      case BuiltinType::Kind::Int:
        element.types.push_back("MPI_INTEGER");
        break;
      case BuiltinType::Kind::UInt:
        element.types.push_back("MPI_UNSIGNED_INTEGER");
        break;
      case BuiltinType::Kind::Long:
        element.types.push_back("MPI_LONG");
        break;
      case BuiltinType::Kind::ULong:
        element.types.push_back("MPI_UNSIGNED_LONG");
        break;
      case BuiltinType::Kind::LongLong:
        element.types.push_back("MPI_LONG_LONG");
        break;
      case BuiltinType::Kind::ULongLong:
        element.types.push_back("MPI_UNSIGNED_LONG_LONG");
        break;
      default:
        llvm::errs() << "Invalid builtin type for MPI mapping " << std::to_string(kind) << "\n";
      }
    }

    else if (type.isConstSizeArrType()) {
      SemaConstSizeArrType* constSizeArrType = (SemaConstSizeArrType*) &type;
      int size = 1;

      while (true) {
        size *= constSizeArrType->elementCount;
        if (!constSizeArrType->elementType->isConstSizeArrType()) break;
        constSizeArrType = (SemaConstSizeArrType *) constSizeArrType->elementType.get();
      }

      auto &elementType = *constSizeArrType->elementType.get();

      if (elementType.isEnumType() || elementType.isPrimitiveType()) {

        MpiElement arrTypeElement = mapMpiElement(elementType, relativeElementOffset);
        for (auto blockLength : arrTypeElement.blockLengths) {
          element.blockLengths.push_back(blockLength + " * " + std::to_string(size));
        }
        for (auto typ : arrTypeElement.types) {
          element.types.push_back(typ);
        }
        for (auto offset : arrTypeElement.offsets) {
          element.offsets.push_back(offset);
        }

      } else {

        size = ((SemaConstSizeArrType*) &type)->size;

        MpiElement arrTypeElement = mapMpiElement(*((SemaConstSizeArrType&) type).elementType, "0");

        for (int i = 0; i < size; i++) {
          for (auto blockLength : arrTypeElement.blockLengths) {
            element.blockLengths.push_back(blockLength);
          }
          for (auto typ : arrTypeElement.types) {
            element.types.push_back(typ);
          }
          for (auto offset : arrTypeElement.offsets) {
            element.offsets.push_back(relativeElementOffset + " + " + "sizeof(" + toSource(elementType) + ") * " + std::to_string(i) + " + " + offset);
          }
        }

      }
    } else if (type.isRecordType()) {
      auto &recordDecl = ((SemaRecordType&) type).recordDecl;

      // check if name ends with __PACKED_CONTAINER
      // if so, treat it as the bitfield container generated by packing
      // and send it as a whole
      auto recordDeclNameRef = llvm::StringRef(recordDecl->name);
      if (recordDeclNameRef.endswith("__PACKED_CONTAINER")) {
        element.blockLengths.push_back("sizeof(" + recordDecl->fullyQualifiedName + ")");
        element.types.push_back("MPI_BYTE");
        element.offsets.push_back(relativeElementOffset);
      } else {
        for (const auto &field : recordDecl->fields) {
          MpiElement fieldElement = mapMpiElement(*field);
          element.blockLengths.insert(element.blockLengths.end(), fieldElement.blockLengths.begin(), fieldElement.blockLengths.end());
          element.types.insert(element.types.end(), fieldElement.types.begin(), fieldElement.types.end());
          for (std::string offset : fieldElement.offsets) {
            element.offsets.push_back(relativeElementOffset + " + " + offset);
          }
        }
      }
    }
    return element;
  }

  std::string getMappingMethodCode(std::vector<std::unique_ptr<SemaFieldDecl>> &fields) {
    SemaRecordDecl& recordDecl = *fields[0]->parent;

    std::string sourceCode = "";

    int nitems;
    std::vector<std::string> blocklengths;
    std::vector<std::string> types;
    std::vector<std::string> offsets;

    for (const auto &field : recordDecl.fields) {
      MpiElement element = this->mapMpiElement(*field->type, "offsetof(" + recordDecl.name + ", " + field->name + ")");
      blocklengths.insert(blocklengths.end(), element.blockLengths.begin(), element.blockLengths.end());
      types.insert(types.end(), element.types.begin(), element.types.end());
      offsets.insert(offsets.end(), element.offsets.begin(), element.offsets.end());
    }

    nitems = blocklengths.size();

    sourceCode += "    static MPI_Datatype *Datatype = nullptr;\n"
                  "    if (Datatype) return *Datatype;\n\n"
                  "    Datatype = new MPI_Datatype;\n"
                  "    int blocklengths[" + std::to_string(nitems) + "] = { ";
    for (auto blocklength : blocklengths) {
      sourceCode += "(" + blocklength + "), ";
    }
    if (blocklengths.size() > 0) { // remove trailing ', '
      sourceCode.pop_back();
      sourceCode.pop_back();
    }
    sourceCode += " };\n\n";

    sourceCode += "    MPI_Datatype types[" + std::to_string(nitems) + "] = { ";
    for (auto type: types) {
      sourceCode += type + ", ";
    }
    if (types.size() > 0) { // remove trailing ', '
      sourceCode.pop_back();
      sourceCode.pop_back();
    }
    sourceCode += " };\n";

    sourceCode += "    MPI_Aint offsets[" + std::to_string(nitems) + "] = {\n";
    for (auto offset : offsets) {
      sourceCode += "        " + offset + ",\n";
    }

    if (offsets.size() > 0) { // remove trailing ', '
      sourceCode.pop_back();
      sourceCode.pop_back();
    }
    sourceCode += "\n    };\n";

    sourceCode += "    MPI_Type_create_struct(" + std::to_string(nitems) + ", blocklengths, offsets, types, Datatype);\n"
                  "    MPI_Type_commit(Datatype);\n"
                  "    return *Datatype;\n";

    return sourceCode;
  }

public:

  bool isMpiMappingCandidate(CXXMethodDecl *D) {
    if (!D->isStatic()) return false;
    for (auto *attr : D->attrs()) {
      if (llvm::isa<MapMpiDatatypeAttr>(attr)) return true;
    }
    return false;
  }

  bool isMpiMappingCandidate(RecordDecl *decl) {
    if (!llvm::isa<CXXRecordDecl>(decl)) return false;
    auto *cxxDecl = llvm::cast<CXXRecordDecl>(decl);
    for (auto *method : cxxDecl->methods()) {
      if (isMpiMappingCandidate(method)) return true;
    }
    return false;
  }

  std::string getMpiMappingMethodBody(RecordDecl *decl) {
    return getMpiMappingMethodBody(decl->getNameAsString(), decl);
  }

  std::string getMpiMappingMethodBody(std::string structName, RecordDecl *decl) {
      auto semaRecordDecl = fromRecordDecl(decl);
      semaRecordDecl->name = structName;
      return getMpiMappingMethodBody(*semaRecordDecl);
  }

  std::string getMpiMappingMethodBody(SemaRecordDecl &decl) {
      return getMpiMappingMethodBody(decl.fields);
  }

  std::string getMpiMappingMethodBody(std::vector<std::unique_ptr<SemaFieldDecl>> &fields) {
      return this->getMappingMethodCode(fields);
  }

  std::string getMpiMappingMethodDef(RecordDecl *decl, SemaRecordDecl &semaDecl) {
    std::string methodName;
    auto *cxxDecl = llvm::cast<CXXRecordDecl>(decl);
    for (auto *method : cxxDecl->methods()) {
      if (!isMpiMappingCandidate(method)) continue;
      methodName = method->getNameAsString();
      break;
    }

    std::string methodDef = "static MPI_Datatype " + methodName + "() {\n" + getMpiMappingMethodBody(semaDecl) + "\n}";
    return methodDef;
  }

};

#endif // CLANG_MPIMAPPINGGENERATOR_H
